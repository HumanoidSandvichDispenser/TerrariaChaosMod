<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Terraria Chaos â€” Vote Overlay</title>

  <!-- Alpine.js (CDN, no build) -->
  <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>

  <style>
    :root {
      --panel: transparent;
      --accent: #db425e;
      --accent-2: #c93864;
      --text: #ffffff;
      --muted: #cbd5e1;
      --bar-bg: rgba(0, 0, 0, 0.65);
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: Inter, Roboto, "Helvetica Neue", Arial, sans-serif;
      background: transparent;
      color: var(--text);
    }

    /* container: transparent background (no panel background) */
    .overlay {
      width: 420px;
      padding: 6px;
      box-sizing: border-box;
      background: var(--panel);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      /* remove heavy shadows/background */
    }

    .options {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .option {
      margin: 0;
    }

    .bar {
      height: 36px;
      width: 100%;
      background: var(--bar-bg);
      border-radius: 10px;
      overflow: hidden;
      position: relative;
      box-sizing: border-box;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }

    /* The fill bar that grows/shrinks */
    .bar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transition: width 500ms cubic-bezier(0.445, 0.050, 0.550, 0.950), background 250ms linear;
      border-radius: 10px 0 0 10px;
      position: absolute;
      left: 0;
      top: 0;
      z-index: 1;
    }

    /* Overlay layer always visible on top of the fill so names remain readable even at 0% */
    .bar-overlay {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 12px;
      z-index: 2;
      pointer-events: none; /* allow clicks to pass if needed */
      color: var(--text);
      font-weight: 700;
      font-size: 14px;
      text-shadow: 0 1px 0 rgba(0,0,0,0.6);
      gap: 8px;
    }

    .bar-overlay .name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      /*flex: 1 1 auto;*/
      min-width: 0;
      padding-right: 8px;
      font-size: 16px;
      color: var(--text);
      text-overflow: ellipsis;
    }

    .bar-overlay .percent {
      /*flex: 0 0 auto;*/
      margin-left: 8px;
      white-space: nowrap;
      font-weight: 800;
      color: var(--text);
    }

    .meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
      padding: 4px 6px 0 6px;
    }

    .status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text);
    }

    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      box-shadow: 0 0 6px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.06);
    }

    .dot-connected {
      background: #22c55e; /* green */
      box-shadow: 0 0 8px rgba(34,197,94,0.35);
    }

    .dot-connecting {
      background: #f59e0b; /* amber */
      box-shadow: 0 0 8px rgba(245,158,11,0.3);
    }

    .dot-error {
      background: #ef4444; /* red */
      box-shadow: 0 0 8px rgba(239,68,68,0.28);
    }

    .dot-disconnected {
      background: #94a3b8; /* gray */
      box-shadow: 0 0 6px rgba(148,163,184,0.18);
    }

    .btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.06);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer;
    }

    .btn:hover {
      border-color: rgba(255,255,255,0.12);
      color: var(--text);
    }

    @media (max-width: 440px) {
      .overlay { width: calc(100% - 24px); padding: 8px; border-radius: 8px; }
      .bar { height: 34px; }
    }

    /*[x-cloak] { display: none !important; }*/
  </style>
</head>
<body>
  <div class="overlay" x-data="voteOverlay()" x-init="init()" x-cloak>
    <div class="options" aria-live="polite">
      <template x-if="options.length === 0">
        <div class="small" style="color:var(--muted); font-size:13px;">Waiting for server message...</div>
      </template>

      <template x-for="(opt, idx) in options" :key="opt.Number">
        <div class="option" :aria-label="opt.Name">
          <div class="bar" role="progressbar" :aria-valuenow="Math.round(percentFor(opt))" aria-valuemin="0" aria-valuemax="100">
            <!-- fill (may be zero width) -->
            <div class="bar-fill" :style="`width:${percentFor(opt)}%`"></div>

            <!-- overlay always shows name and percent inside the bar, even when fill is 0% -->
            <div class="bar-overlay">
              <span class="number" x-text="opt.Number"></span>
              <span class="name" x-text="opt.Name"></span>
              <span class="percent" x-text="displayPercent(opt)"></span>
            </div>
          </div>
        </div>
      </template>
    </div>

    <div class="meta">
      <div class="status">
        <span class="status-dot"
              :class="{
                'dot-connected': statusText === 'connected',
                'dot-connecting': statusText === 'connecting...',
                'dot-error': statusText === 'error',
                'dot-disconnected': statusText === 'disconnected' || statusText.startsWith('reconnecting')
              }"
              aria-hidden="true"></span>
        <span x-text="statusText"></span>
      </div>

      <div style="display:flex; gap:8px; align-items:center;">
        <input
          type="number"
          min="1"
          max="65535"
          x-model.number="port"
          @keyup.enter="forceReconnect()"
          title="WebSocket port"
          placeholder="Port"
          style="width:88px;padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text);font-size:13px;"
        />
        <button class="btn" x-on:click="forceReconnect()">Reconnect</button>
      </div>
    </div>
  </div>

  <script>
    function voteOverlay() {
      return {
        ws: null,
        statusText: "disconnected",
        options: [],
        reconnectDelay: 1000,
        maxDelay: 10000,
        shouldReconnect: true,
        port: 9091,
        scheduledReconnectId: null,

        init() {
          this.connect();
          window.__voteOverlay = this;
        },

        connect() {
          if (this.ws) {
            try {
              this.ws.close();
            } catch (err) {
              console.warn("Error closing previous ws", err);
            }
            this.ws = null;
          }

          this.statusText = "connecting...";

          try {
            this.ws = new WebSocket(`ws://localhost:${this.port}/ws`);
          } catch (err) {
            console.error("WebSocket creation failed", err);
            this.statusText = "error";
            this.scheduleReconnect();
            return;
          }

          this.ws.addEventListener("open", () => {
            this.reconnectDelay = 1000;
            this.statusText = "connected";
          });

          this.ws.addEventListener("message", (ev) => {
            try {
              this.onMessage(ev.data);
            } catch (err) {
              console.warn("Message handling error", err);
            }
          });

          this.ws.addEventListener("close", () => {
            this.statusText = "disconnected";
            if (this.shouldReconnect) {
              this.scheduleReconnect();
            }
          });

          this.ws.addEventListener("error", (err) => {
            console.warn("WebSocket error", err);
            this.statusText = "error";
            // close event will handle reconnect
          });
        },

        scheduleReconnect() {
          this.statusText = `reconnecting in ${this.reconnectDelay / 1000}s...`;

          if (this.scheduledReconnectId) {
            clearTimeout(this.scheduledReconnectId);
            this.scheduledReconnectId = null;
          }

          this.scheduledReconnectId = setTimeout(() => {
            if (!this.shouldReconnect) {
              return;
            }
            this.connect();
            this.reconnectDelay = Math.min(this.maxDelay, Math.floor(this.reconnectDelay * 1.8));
          }, this.reconnectDelay);
        },

        forceReconnect() {
          this.reconnectDelay = 1000;
          this.shouldReconnect = true;
          if (this.ws) {
            try {
              this.ws.close();
            } catch (err) {
              console.warn("Error closing ws for forceReconnect", err);
            }
          }
          this.connect();
        },

        onMessage(raw) {
          let data;
          try {
            data = JSON.parse(raw);
          } catch (err) {
            console.warn("Invalid JSON from WS:", raw);
            return;
          }

          if (!data || !Array.isArray(data.Options)) {
            console.warn("Unexpected payload shape", data);
            return;
          }

          const incoming = data.Options.map((o) => {
            const num = Number(o.Number ?? 0);
            const name = String(o.Name ?? "Unnamed");
            let proportion = Number(o.Proportion ?? 0);
            if (!isFinite(proportion)) {
              proportion = 0;
            }
            proportion = Math.max(0, Math.min(1, proportion));
            return { Number: num, Name: name, Proportion: proportion };
          });

          this.options = incoming;
        },

        percentFor(opt) {
          if (!opt || typeof opt.Proportion !== "number") {
            return 0;
          }
          const p = opt.Proportion * 100;
          if (!isFinite(p)) {
            return 0;
          }
          return Math.max(0, Math.min(100, p));
        },

        displayPercent(opt) {
          const p = this.percentFor(opt);
          return Math.round(p) + "%";
        }
      };
    }
  </script>
</body>
</html>
